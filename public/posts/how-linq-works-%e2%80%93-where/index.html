<!DOCTYPE html>
<html lang="en-au">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>How LINQ Works – Where | The Wandering Glitch</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Attachments: 2006/11/expression.PNG
I went digging under the surface of the LINQ query extension and iterators recently - I wanted to know how much I pay for the simplicity I get with APIs from the System.Query namespace. This post explores a little of the implementation of one of the key parts of the LINQ system. I&rsquo;m starting out with the System.Query.Sequence.Where extension method because it follows on nicely from the last post on LINQ and Reflection.">
    <meta name="generator" content="Hugo 0.92.2" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="How LINQ Works – Where" />
<meta property="og:description" content="Attachments: 2006/11/expression.PNG
I went digging under the surface of the LINQ query extension and iterators recently - I wanted to know how much I pay for the simplicity I get with APIs from the System.Query namespace. This post explores a little of the implementation of one of the key parts of the LINQ system. I&rsquo;m starting out with the System.Query.Sequence.Where extension method because it follows on nicely from the last post on LINQ and Reflection." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://45.89.107.9/posts/how-linq-works-%e2%80%93-where/" /><meta property="article:section" content="posts" />



<meta itemprop="name" content="How LINQ Works – Where">
<meta itemprop="description" content="Attachments: 2006/11/expression.PNG
I went digging under the surface of the LINQ query extension and iterators recently - I wanted to know how much I pay for the simplicity I get with APIs from the System.Query namespace. This post explores a little of the implementation of one of the key parts of the LINQ system. I&rsquo;m starting out with the System.Query.Sequence.Where extension method because it follows on nicely from the last post on LINQ and Reflection.">

<meta itemprop="wordCount" content="1280">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How LINQ Works – Where"/>
<meta name="twitter:description" content="Attachments: 2006/11/expression.PNG
I went digging under the surface of the LINQ query extension and iterators recently - I wanted to know how much I pay for the simplicity I get with APIs from the System.Query namespace. This post explores a little of the implementation of one of the key parts of the LINQ system. I&rsquo;m starting out with the System.Query.Sequence.Where extension method because it follows on nicely from the last post on LINQ and Reflection."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        The Wandering Glitch
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="Posts page">
              Posts
            </a>
          </li>
          
        </ul>
      
      
<div class="ananke-socials">
  
    
    <a href="https://techhub.social/@aabs" target="_blank" rel="me noopener" class="mastodon ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Mastodon link" aria-label="follow on Mastodon——Opens in a new window">
      
        <span class="icon"><svg style="enable-background:new 0 0 230 230;" version="1.1" viewBox="0 0 230 230"  xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<path d="M211.80683 139.0875c-3.1825 16.36625-28.4925 34.2775-57.5625 37.74875-15.16 1.80875-30.0825 3.47125-45.99875 2.74125-26.0275-1.1925-46.565-6.2125-46.565-6.2125 0 2.53375.15625 4.94625.46875 7.2025 3.38375 25.68625 25.47 27.225 46.3925 27.9425 21.115.7225 39.91625-5.20625 39.91625-5.20625l.86875 19.09s-14.77 7.93125-41.08125 9.39c-14.50875.7975-32.52375-.365-53.50625-5.91875C9.23183 213.82 1.40558 165.31125.20808 116.09125c-.36375-14.61375-.14-28.39375-.14-39.91875 0-50.33 32.97625-65.0825 32.97625-65.0825C49.67058 3.45375 78.20308.2425 107.86433 0h.72875c29.66125.2425 58.21125 3.45375 74.8375 11.09 0 0 32.97625 14.7525 32.97625 65.0825 0 0 .4125 37.13375-4.6 62.915" style="fill-rule:evenodd;clip-rule:evenodd;"/>
<path d="M65.68743 96.45938c0 9.01375-7.3075 16.32125-16.3225 16.32125-9.01375 0-16.32-7.3075-16.32-16.32125 0-9.01375 7.30625-16.3225 16.32-16.3225 9.015 0 16.3225 7.30875 16.3225 16.3225M124.52893 96.45938c0 9.01375-7.30875 16.32125-16.3225 16.32125-9.01375 0-16.32125-7.3075-16.32125-16.32125 0-9.01375 7.3075-16.3225 16.32125-16.3225 9.01375 0 16.3225 7.30875 16.3225 16.3225M183.36933 96.45938c0 9.01375-7.3075 16.32125-16.32125 16.32125-9.01375 0-16.32125-7.3075-16.32125-16.32125 0-9.01375 7.3075-16.3225 16.32125-16.3225 9.01375 0 16.32125 7.30875 16.32125 16.3225" fill="#fff"/>
</svg>
</span>
      
<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000"  xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;"/>
</svg>
</span></a>
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">How LINQ Works – Where</h1>
      
      <p class="tracked">
        By <strong>Andrew Matthews</strong>
      </p>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links #000000 pr4-l w-two-thirds-l"><p>Attachments: 2006/11/expression.PNG</p>
<p>I went digging under the surface of the LINQ query extension and iterators recently - I wanted to know how much I pay for the simplicity I get with APIs from the System.Query namespace. This post explores a little of the implementation of one of the key parts of the LINQ system. I&rsquo;m starting out with the System.Query.Sequence.Where extension method because it follows on nicely from the <a href="http://aabs.wordpress.com/2006/11/13/linq-reflection-in-c-30/">last post</a> on LINQ and Reflection.</p>
<p>An extension method is just a syntactic alternative to a normal static method that takes as its first argument a type that it will manipulate. An extension can&rsquo;t do anything that a normal static method can&rsquo;t, therefore we can ignore the method itself – it&rsquo;s the object model that counts in LINQ, and the framework of expressions and iterators that it depends on.</p>
<p>I&rsquo;ll start out by exploring the implementation of Sequence.Where. I will use the convention of referring to it as IEnumerable&lt;T&gt;.Where in places because, being an extension method, it extends IEnumerable&lt;T&gt; because that&rsquo;s its first argument. The Where method doesn&rsquo;t do a whole lot before delegating to an internal WhereIterator object that iterates the collection:</p>
<p><code>[Extension] public static IEnumerable&lt;T&gt; Where&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt;predicate) {   if (source == null)   {     throw Error.ArgumentNull(&quot;source&quot;);   }   if (predicate == null)   {     throw Error.ArgumentNull(&quot;predicate&quot;);   }   return Sequence.WhereIterator&lt;T&gt;(source, predicate); }</code></p>
<p>[All it does is a bit of validation before invoking Sequence.WhereIterator&lt;T&gt;. The WhereIterator method does the same with a code-generated class that Reflector reports as <a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Object=7">[Sequence]{style=&ldquo;color:#006018;&quot;}</a>.<a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Object=8" title="System.Query.Sequence+&lt;WhereIterator&gt;d__0&lt;T&gt;.&lt;WhereIterator&gt;d__0&lt;T&gt;(int);">[&lt;WhereIterator&gt;d__0]{style=&ldquo;color:#006018;&quot;}</a>&lt;T&gt;. This is just a conversion of the C# syntax for iteration into plainer fare. If we take a peek at the relevant piece of decompiled code for the iterator we see the code for the iteration. It&rsquo;s pretty ugly, and not much worth reading except to get an idea of how the iteration takes place.
]{style=&ldquo;font-size:8pt;font-family:Tahoma;&quot;}</p>
<pre><code>private bool MoveNext()
{
      bool flag1;
      try
      {
            switch (this.&lt;&gt;1__state)
            {
                  case 0:
                        this.&lt;&gt;1__state = -1;
                        this.&lt;&gt;7__wrap2 = this.source.GetEnumerator();
                        this.&lt;&gt;1__state = 1;
                        goto Label_0081;

                  case 1:
                        goto Label_00A8;

                  case 2:
                        goto Label_007A;

                  default:
                        goto Label_00A8;
            }

     Label_003F:
            this.&lt;element&gt;5__1 = this.&lt;&gt;7__wrap2.Current;
            if (!this.predicate(this.&lt;element&gt;5__1))
            {
                  goto Label_0081;
            }
            this.&lt;&gt;2__current = this.&lt;element&gt;5__1;
            this.&lt;&gt;1__state = 2;
            return true;
      Label_007A:
            this.&lt;&gt;1__state = 1;
      Label_0081:
            if (this.&lt;&gt;7__wrap2.MoveNext())
            {
                  goto Label_003F;
            }
            this.&lt;&gt;1__state = -1;
            if (this.&lt;&gt;7__wrap2 != null)
            {
                  this.&lt;&gt;7__wrap2.Dispose();
            }
      Label_00A8:
            flag1 = false;
      }
      fault
      {
            ((IDisposable) this).Dispose();
      }
      return flag1;
}
</code></pre>
<p>Under the label Label_003F the predicate passed to Where is invoked on the current item. If the result is false, the iterator jumps to Label_0081 where it skips forward one place, before going back to check the predicate again. So in essence the iterator came from something like this:</p>
<pre><code>foreach (T val in collection)
{
    if(predicate(val))
        yield return val;
}
</code></pre>
<p>Aside from noting the foreach syntax&rsquo;s brevity, we can also see that the efficiency of the Where method is directly related to the efficiency of the iterator of the underlying collection class. Every item in the collection has to be visited, and compared before the WhereIterator can decide whether to yield it to the caller. That means that in large collections where the time to iterate the whole collection is significant, Where&rsquo;s filtering capabilities are not guaranteed to speed up your iterations. I say not guaranteed, as though there might be cases where that&rsquo;s not the case, because there are two Where extensions and it all depends on the capabilities of the iterator on the collection we are filtering. Another extension method (System.Query.Queryable.Where) extends the IQueryable&lt;T&gt; interface, and has the potential to go a long way further than the Where on IEnumerable&lt;T&gt;.</p>
<p>IEnumerable&lt;T&gt; iterates a collection that has already been created and instantiated. IEnumerable&lt;T&gt;.Where just iterates it. IQueryable&lt;T&gt;.Where is an altogether different sort of extension, and deserves much more interest than the common-or-garden selection mechanism in System.Query.Sequence.Where.</p>
<pre><code>[Extension]
public static IQueryable&lt;T&gt;Where&lt;T&gt;(IQueryable&lt;T&gt; source, Expression&lt;Func&lt;T, bool&gt;&gt;predicate)
{
      if (source == null)
      {
            throw new ArgumentNullException(&quot;source&quot;);
      }
      if (predicate == null)
      {
            throw new ArgumentNullException(&quot;predicate&quot;);
      }
      return source.CreateQuery&lt;T&gt;(Expression.Call(((MethodInfo) MethodBase.GetCurrentMethod())
.MakeGenericMethod(new Type[] { typeof(T) }), null, new Expression[] {
source.Expression, predicate }));
}
</code></pre>
<p>There&rsquo;s a lot more going on here than in the case of IEnumerable&lt;T&gt;.Where. We have the same pattern of validation, followed by delegation to another class. In this case the delegation happens when the CreateQuery method is invoked on the IQueryable&lt;T&gt; object of the method. Since we know that the first parameter of an extension method is the object being extended we know that the query we call it on is being called. Here the implementation being used is in System.Query.SequenceQuery&lt;T&gt;.CreateQuery. It also follows the same validate &amp; delegate pattern. This time it creates a new SequenceQuery&lt;T&gt; instance out of the parameters passed to Where&lt;T&gt;. let&rsquo;s first take a look at what happens in the Expression.Call method:</p>
<pre><code>public static MethodCallExpression Call(MethodInfo method, Expression obj, IEnumerable&lt;Expression&gt;parameters)
{
      ReadOnlyCollection&lt;Expression&gt; collection2 = ReadOnlyCollectionExtensions.ToReadOnlyCollection&lt;Expression&gt;(parameters);
      Expression.ValidateCallArgs(method, obj, collection2);
      return new MethodCallExpression(ExpressionType.MethodCall, method, obj, collection2);
}
</code></pre>
<p>The first thing it does is create a read-only collection out of the parameters – which in this case are the Expression from the source query, and the predicate object that is passed to the Where method to begin with. This collection is then validated. Finally a new MethodCallExpression is created out of a new generic method, and the collection of params created previously. The generic method is created in a subclass of MethodBase in System.Reflection. It creates a method that has a type parameter of type T (i.e. whatever type we were dealing with in the IQueryable&lt;T&gt;). The method created is a stub, to give the LINQ system details about the predicate that it needs to call later on. It needs to do this because it won&rsquo;t be calling the predicate immediately, and it needs to store a reference to the method in an expression tree.</p>
<p>At this point we have created a new Expression object with a new root of type MethodCallExpression. It has branches that are the reference to the initial Expression passed as a parameter to the Where method and the predicate that we plan to use later on. Interestingly the Expression.Call method takes a parameter called obj that is not used in this case. You might have expected it to be passed the initial Expression as this parameter since that argument calls for an Expression, but instead the original expression is stored as an element in the parameters collection of the new root node.</p>
<p><a href="%7Bstatic%7D2006/11/expression.PNG" title="The Expression Tree"><img src="%7Bstatic%7D2006/11/expression.PNG" alt="The Expression Tree"></a></p>
<p>[**Figure 1. The New Expression tree created by a call to Queryable.Where
**]{style=&ldquo;font-size:9pt;color:#4f81bd;&quot;}</p>
<p>It&rsquo;s just added a node to an expression tree, and done no iteration at all. This is why Queryable.Where is so different from the first extension on IEnumerable&lt;T&gt;. It leaves the interpretation of the expression tree till later. This is very cool because it means you can create these expression trees, store them, serialize them, and pass them around. You invoke them later like a normal iterator when you&rsquo;re ready for the data. A key scenario for this sort of capability is ad-hoc querying. You can build these queries up as the user chooses search criteria to be added to the expression tree, and then go get the results later on.</p>
<p>Next time, I&rsquo;ll show you how the iteration works on normal Sequences such as we might get from reflection, and we&rsquo;ll take a peek at how things work in the case of DLINQ (LINQ to SQL). In DLINQ a lot of ORM intelligence is hidden under the hood of the iterator and the Expression tree. We&rsquo;ll see that the beauty of LINQ is that it manages to cleanly encapsulate the technology we need to get to the data we&rsquo;re working with. As I said in a <a href="http://aabs.wordpress.com/2006/11/01/intrusive-technology/">previous post</a>, it&rsquo;s vitally important to creating robust and maintainable code.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://45.89.107.9/" >
    &copy;  The Wandering Glitch 2022 
  </a>
    <div>
<div class="ananke-socials">
  
    
    <a href="https://techhub.social/@aabs" target="_blank" rel="me noopener" class="mastodon ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Mastodon link" aria-label="follow on Mastodon——Opens in a new window">
      
        <span class="icon"><svg style="enable-background:new 0 0 230 230;" version="1.1" viewBox="0 0 230 230"  xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<path d="M211.80683 139.0875c-3.1825 16.36625-28.4925 34.2775-57.5625 37.74875-15.16 1.80875-30.0825 3.47125-45.99875 2.74125-26.0275-1.1925-46.565-6.2125-46.565-6.2125 0 2.53375.15625 4.94625.46875 7.2025 3.38375 25.68625 25.47 27.225 46.3925 27.9425 21.115.7225 39.91625-5.20625 39.91625-5.20625l.86875 19.09s-14.77 7.93125-41.08125 9.39c-14.50875.7975-32.52375-.365-53.50625-5.91875C9.23183 213.82 1.40558 165.31125.20808 116.09125c-.36375-14.61375-.14-28.39375-.14-39.91875 0-50.33 32.97625-65.0825 32.97625-65.0825C49.67058 3.45375 78.20308.2425 107.86433 0h.72875c29.66125.2425 58.21125 3.45375 74.8375 11.09 0 0 32.97625 14.7525 32.97625 65.0825 0 0 .4125 37.13375-4.6 62.915" style="fill-rule:evenodd;clip-rule:evenodd;"/>
<path d="M65.68743 96.45938c0 9.01375-7.3075 16.32125-16.3225 16.32125-9.01375 0-16.32-7.3075-16.32-16.32125 0-9.01375 7.30625-16.3225 16.32-16.3225 9.015 0 16.3225 7.30875 16.3225 16.3225M124.52893 96.45938c0 9.01375-7.30875 16.32125-16.3225 16.32125-9.01375 0-16.32125-7.3075-16.32125-16.32125 0-9.01375 7.3075-16.3225 16.32125-16.3225 9.01375 0 16.3225 7.30875 16.3225 16.3225M183.36933 96.45938c0 9.01375-7.3075 16.32125-16.32125 16.32125-9.01375 0-16.32125-7.3075-16.32125-16.32125 0-9.01375 7.3075-16.3225 16.32125-16.3225 9.01375 0 16.32125 7.30875 16.32125 16.3225" fill="#fff"/>
</svg>
</span>
      
<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000"  xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;"/>
</svg>
</span></a>
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
