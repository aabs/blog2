<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Knowledge Graphs 7 - Named Graphs | The Wandering Glitch</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Knowledge Graphs provide a neat and easy way to segment your data, called &lsquo;Named Graphs&rsquo;. This post shows how you access them, and different uses they may be put to.
This is part 7 of an ongoing series providing a little background on Knowledge Graphs. The aim is to let software developers get up to speed as fast as possible. No theory, no digressions, and no history. Just practical knowledge.">
    <meta name="generator" content="Hugo 0.92.2" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Knowledge Graphs 7 - Named Graphs" />
<meta property="og:description" content="Knowledge Graphs provide a neat and easy way to segment your data, called &lsquo;Named Graphs&rsquo;. This post shows how you access them, and different uses they may be put to.
This is part 7 of an ongoing series providing a little background on Knowledge Graphs. The aim is to let software developers get up to speed as fast as possible. No theory, no digressions, and no history. Just practical knowledge." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://45.89.107.9/posts/knowledge-graphs-7-named-graphs/" /><meta property="article:section" content="posts" />



<meta itemprop="name" content="Knowledge Graphs 7 - Named Graphs">
<meta itemprop="description" content="Knowledge Graphs provide a neat and easy way to segment your data, called &lsquo;Named Graphs&rsquo;. This post shows how you access them, and different uses they may be put to.
This is part 7 of an ongoing series providing a little background on Knowledge Graphs. The aim is to let software developers get up to speed as fast as possible. No theory, no digressions, and no history. Just practical knowledge.">

<meta itemprop="wordCount" content="1356">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Knowledge Graphs 7 - Named Graphs"/>
<meta name="twitter:description" content="Knowledge Graphs provide a neat and easy way to segment your data, called &lsquo;Named Graphs&rsquo;. This post shows how you access them, and different uses they may be put to.
This is part 7 of an ongoing series providing a little background on Knowledge Graphs. The aim is to let software developers get up to speed as fast as possible. No theory, no digressions, and no history. Just practical knowledge."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        The Wandering Glitch
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Knowledge Graphs 7 - Named Graphs</h1>
      
      <p class="tracked">
        By <strong>aabs</strong>
      </p>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Knowledge Graphs provide a neat and easy way to segment your data, called
&lsquo;<em>Named Graphs</em>&rsquo;. This post shows how you access them, and different uses they
may be put to.</p>
<p>This is part 7 of an ongoing series providing a little background on <em>Knowledge Graphs</em>. The aim is to let software developers get up to speed as fast as possible. No theory, no digressions, and no history. Just practical knowledge.</p>
<ul>
<li><a href="https://andrewmatthews.blog/2019/09/12/knowledge-graphs-101/">Knowledge Graphs 101</a></li>
<li><a href="https://andrewmatthews.blog/2019/09/13/knowledge-graphs-2-playing-on-the-cli/">Knowledge Graphs 2 – Playing on the CLI</a></li>
<li><a href="https://andrewmatthews.blog/2019/09/13/knowledge-graphs-3-using-a-triple-store/">Knowledge Graphs 3 – Using a Triple Store</a></li>
<li><a href="https://andrewmatthews.blog/2019/09/16/knowledge-graphs-4-querying-your-knowledge-graph-using-net/">Knowledge Graphs 4 – Querying your knowledge graph using .NET</a></li>
<li><a href="https://andrewmatthews.blog/2019/10/03/knowledge-graphs-5-modelling-with-rdfs/">Knowledge Graphs 5 – Modelling with RDFS</a></li>
<li><a href="https://andrewmatthews.blog/2019/10/03/knowledge-graphs-6-semantics/">Knowledge Graphs 6 - Semantics</a></li>
<li><a href="https://aabs.wordpress.com/2019/11/06/knowledge-graphs-7-named-graphs/">Knowledge Graphs 7 - Named graphs</a></li>
</ul>
<p>Named graphs are a useful feature, providing ways to segregate and independently managed subsets of the data. At first glance they seem akin to tables in SQL. But they TOTALLY AREN&rsquo;T. Let&rsquo;s take a look at what they are, and how different folks use them.</p>
<h2 id="inserting-data-into-a-named-graph">Inserting data into a NAMED GRAPH</h2>
<p>Inserting data into a named graph is easy - you enclose the triples you wish to create in a graph block:</p>
<pre tabindex="0"><code>PREFIX s: &lt;http://tempuri.com/soccer/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

INSERT DATA {
    GRAPH s:ArsenalFC {
        s:ArsenalFC a s:Team;
            s:homeCity s:London;
            rdfs:label &quot;Arsenal F.C.&quot; .
    }

    GRAPH s:ChelseaFC {
        s:ChelseaFC a s:Team;
            s:homeCity s:London;
            rdfs:label &quot;Chelsea F.C.&quot; .
    }

    GRAPH s:LiverpoolFC {
        s:LiverpoolFC a s:Team;
            s:homeCity s:Liverpool;
            rdfs:label &quot;Liverpool F.C.&quot; .
    }
}
</code></pre><p>This creates three graphs (or adds to them if they already existed) with subsets of the data. Here, we are putting  <code>s:ArsenalFC</code> data just in the graph of the same name. That&rsquo;s convenient, because you only need to know the name of the team to know what graph its data is stored in.</p>
<h2 id="finding-graphs-and-their-data">Finding Graphs and Their Data</h2>
<p>You can query for the graph URI at the same time as binding any other variable in the data. Here, I will get the team data and the graph URI out together:</p>
<pre tabindex="0"><code>PREFIX s: &lt;http://tempuri.com/soccer/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT *
WHERE {
    GRAPH ?graph {
        ?team a s:Team;
            s:homeCity ?city;
            rdfs:label ?name .
    }
}
</code></pre><p>which gives us</p>
<pre tabindex="0"><code>------------------------------------------------------------------
| team          | graph         | city        | name             |
==================================================================
| s:ArsenalFC   | s:ArsenalFC   | s:London    | &quot;Arsenal F.C.&quot;   |
| s:ChelseaFC   | s:ChelseaFC   | s:London    | &quot;Chelsea F.C.&quot;   |
| s:LiverpoolFC | s:LiverpoolFC | s:Liverpool | &quot;Liverpool F.C.&quot; |
------------------------------------------------------------------
</code></pre><p>So, quite naturally, if I wanted to restrict myself to everything we know about Arsenal, that&rsquo;s quite easy:</p>
<pre tabindex="0"><code>PREFIX s: &lt;http://tempuri.com/soccer/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT *
WHERE {
    GRAPH s:ArsenalFC {
        ?s ?p ?o .
    }
}
</code></pre><p>giving us</p>
<pre tabindex="0"><code>---------------------------------------------
| s           | p          | o              |
=============================================
| s:ArsenalFC | s:homeCity | s:London       |
| s:ArsenalFC | rdf:type   | s:Team         |
| s:ArsenalFC | rdfs:label | &quot;Arsenal F.C.&quot; |
---------------------------------------------
</code></pre><h3 id="everything-everything">Everything everything</h3>
<p>If you want to get everything back from your triple store, and this varies somewhat between triple stores, then you need to get the union of named graphs combined with the <strong>default graph</strong>.</p>
<pre tabindex="0"><code>PREFIX s:
PREFIX rdfs:

SELECT *
WHERE {
  {
    GRAPH ?g {
        ?s ?p ?o .
    }
  }
  UNION
  {
    ?s ?p ?o .
  }
}
</code></pre><p>The way this works is defined in the [SPARQL spec](<a href="https://www.w3.org/TR/sparql11-query/">https://www.w3.org/TR/sparql11-query/</a>#queryDataset), but there still seems to be some variance in implementations between vendors. For example, we see [this](<a href="https://docs.aws.amazon.com/neptune/latest/userguide/best-practices-sparql-query.html">https://docs.aws.amazon.com/neptune/latest/userguide/best-practices-sparql-query.html</a>) guidance from Amazon. They have chosen to return the  <code>RDF Merge </code>of all named graphs in addition to the default graph.</p>
<h3 id="another-way-to-pull-from-a-named-graph">Another way to pull from a named graph</h3>
<p>Another convenient syntax for pulling from a specific named graph is shown here. Let&rsquo;s get back everything from Liverpool this time:</p>
<pre tabindex="0"><code>PREFIX s: &lt;http://tempuri.com/soccer/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT *
FROM s:LiverpoolFC
WHERE {
  ?s ?p ?o .
}
</code></pre><pre tabindex="0"><code>-------------------------------------------------
| s             | p          | o                |
=================================================
| s:LiverpoolFC | s:homeCity | s:Liverpool      |
| s:LiverpoolFC | rdf:type   | s:Team           |
| s:LiverpoolFC | rdfs:label | &quot;Liverpool F.C.&quot; |
-------------------------------------------------
</code></pre><p>This approach to pulling all the data back from a graph is one of several approaches to <em>bulk retrieval</em>. This is a convenient way to perform local analysis or processing on a cohesive subset of the data.</p>
<h2 id="common-uses-for-named-graphs">Common Uses for Named Graphs</h2>
<p>Now we&rsquo;ve seen a few different ways to insert and retrieve data from a named graph, let&rsquo;s take a brief, non-judgemental, looks at the various ways that people use the named graph feature.</p>
<h3 id="bulk-retrieval">Bulk Retrieval</h3>
<p>One simple purpose to named graphs is to lump together a bunch of data that you are likely to want to get back at the same time. SPARQL 1.1 Query standard provides a simple RESTful mechanism to pull the entire contents of a graph in one pass.</p>
<pre tabindex="0"><code>GET /rdf-graph-store?graph=http%3A//www.example.com/other/graph HTTP/1.1
   Host: example.com
   Accept: text/turtle; charset=utf-8
</code></pre><p>This is particularly useful if you want to be able to dynamically process the contents of the graph by walking it locally. It allows you to employ graph algorithms that would be prohibitively expensive if you had to factor in network latency for walking each edge of the graph.</p>
<h3 id="tracking-where-data-came-from">Tracking Where Data Came From</h3>
<p>If you can provide information, such as as a URL, to identify where the contents of a graph came from, then it can often be useful to keep track of that for provenance purposes. Many common frameworks will load incoming data from a file loader into a named graph where the URI of the graph identifies where the data came from. This is popular in the Linked Data community, where the gathering and merging of data from multiple sources means the provenance and trustworthiness of data sources must be tracked, in case of disputed conclusions.</p>
<h3 id="replicate-the-data-in-a-graph">Replicate the data in a Graph</h3>
<p>Another way to use a named graph is as a temporary storage mechanism, allowing the state of the graph to be captured, duplicated or transmitted. This might be done to allow in-place modifications with the option of rollback.</p>
<h3 id="tracking-data-versions-and-updates">Tracking data versions and updates</h3>
<p>Similarly, one might systematically label duplicate copies of data to allow the tracking of how the data changed over time. This is similar to approach above.</p>
<h3 id="control-access-to-data">Control Access to data</h3>
<p>Some triple store platforms allow the definition of security access controls on a per-graph basis. In that case the named graph can be used to support mechanisms like tenancy and ownership of data.</p>
<h3 id="attach-metadata-to-the-graph-rather-than-its-contents">Attach Metadata to the graph rather than its contents</h3>
<p>Lastly, the cool thing about having all your data in a graph identified by a URI is that you can then make a whole bunch of statements about that graph.</p>
<pre tabindex="0"><code>PREFIX s: &lt;http://tempuri.com/soccer/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX staff: &lt;http://industrialinference.com/staff/&gt;

INSERT DATA {
    GRAPH s:ArsenalFC_Imported {
        s:ArsenalFC a s:Team;
            s:homeCity s:London;
            rdfs:label &quot;Arsenal F.C.&quot; .
        # etc etc etc
    }
    # . . .
    GRAPH s:Stats_Import_Metadata {
        s:ArsenalFC_Imported a :Graph;
            s:statsKind &quot;Goal Averages&quot;;
            s:keyEntityDescribed s:ArsenalFC;
            dc:creator staff:andrewm;
            dc:publisher &quot;Football Association&quot;;
            dc:date  &quot;2017-01-07&quot;;
            dc:title &quot;Arsenal Stats&quot;;
            dc:description &quot;Arsenal Stats from FA site&quot; ;
            dc:language &quot;en&quot; .
        # etc etc etc
    }
}
</code></pre><p>The potential for this kind of easily augmented and expanded metadata is limitless. There&rsquo;s a single place to go for all the metadata, and it can tell you with a short query what kinds of data we have in graphs. Let&rsquo;s see what Goal Averages stats we have on Arsenal:</p>
<pre tabindex="0"><code>PREFIX s: &lt;http://tempuri.com/soccer/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT *
WHERE {
    GRAPH s:Stats_Import_Metadata {
        ?statsDataSet
            s:statsKind &quot;Goal Averages&quot;;
            s:keyEntityDescribed s:ArsenalFC;
            dc:creator ?creator;
            dc:publisher ?publisher;
            dc:date ?creationDate;
            dc:title ?title;
            dc:description ?description .
    }
}
</code></pre><h2 id="summary">Summary</h2>
<p>In this installment, I showed you Named Graphs, how to insert data into them, how to get it back out, then mentioned a few cool ways to use them to help organise your data.</p>
<p>There&rsquo;s surely a lot more to say about this topic, but I was in danger of getting writer&rsquo;s block. Instead, please let me know what topics you are interested in so I can cover them at some point.</p>
<p>Next time, I hope to investigate the topic of inference, showing a few ways this can be done, and introducing you to a little side project I have been working on that might one day yield a useful inference engine in .NET.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://45.89.107.9/" >
    &copy;  The Wandering Glitch 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
