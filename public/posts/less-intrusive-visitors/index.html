<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Less Intrusive Visitors | The Wandering Glitch</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Forgive the recent silence - I&rsquo;ve been in my shed.
Frequently, I need some variation on the Visitor or HierarchicalVisitor patterns to analyse or transform an object graph. Recent work on a query builder for an old-skool query API sent my thoughts once again to the Visitor pattern. I normally hand roll these frameworks based on my experiences with recursive descent compilers, but this time I thought I&rsquo;d produce a more GoF-compliant implementation.">
    <meta name="generator" content="Hugo 0.92.2" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Less Intrusive Visitors" />
<meta property="og:description" content="Forgive the recent silence - I&rsquo;ve been in my shed.
Frequently, I need some variation on the Visitor or HierarchicalVisitor patterns to analyse or transform an object graph. Recent work on a query builder for an old-skool query API sent my thoughts once again to the Visitor pattern. I normally hand roll these frameworks based on my experiences with recursive descent compilers, but this time I thought I&rsquo;d produce a more GoF-compliant implementation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://45.89.107.9/posts/less-intrusive-visitors/" /><meta property="article:section" content="posts" />



<meta itemprop="name" content="Less Intrusive Visitors">
<meta itemprop="description" content="Forgive the recent silence - I&rsquo;ve been in my shed.
Frequently, I need some variation on the Visitor or HierarchicalVisitor patterns to analyse or transform an object graph. Recent work on a query builder for an old-skool query API sent my thoughts once again to the Visitor pattern. I normally hand roll these frameworks based on my experiences with recursive descent compilers, but this time I thought I&rsquo;d produce a more GoF-compliant implementation.">

<meta itemprop="wordCount" content="1037">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Less Intrusive Visitors"/>
<meta name="twitter:description" content="Forgive the recent silence - I&rsquo;ve been in my shed.
Frequently, I need some variation on the Visitor or HierarchicalVisitor patterns to analyse or transform an object graph. Recent work on a query builder for an old-skool query API sent my thoughts once again to the Visitor pattern. I normally hand roll these frameworks based on my experiences with recursive descent compilers, but this time I thought I&rsquo;d produce a more GoF-compliant implementation."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        The Wandering Glitch
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Less Intrusive Visitors</h1>
      
      <p class="tracked">
        By <strong>aabs</strong>
      </p>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Forgive the recent silence - I&rsquo;ve been in my shed.</p>
<p>Frequently, I need some variation on the Visitor or HierarchicalVisitor patterns
to analyse or transform an object graph. Recent work on a query builder
for an old-skool query API sent my thoughts once again to the Visitor pattern. I
normally hand roll these frameworks based on my experiences with recursive
descent compilers, but this time I thought I&rsquo;d produce a more GoF-compliant
implementation.</p>
<p>The standard implementation of the visitor looks a lot like the first code example. First you
define some sort of domain model (often following the composite pattern).
This illustration doesn&rsquo;t bother with composite. I&rsquo;ll show one later on, with an
accompanying HierarchicalVisitor implementation.</p>
<p>[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]abstract class BaseElement {
void Accept(IVisitor v);
 }
class T1 : BaseElement {
  void Accept(IVisitor v) {
    v.visit(this);
  }
}
class T2 : BaseElement {
  void Accept(IVisitor v) {
    v.visit(this);
  }
}
class T3 : BaseElement {
  void Accept(IVisitor v) {
    v.visit(this);
  }
}[/sourcecode]
[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]interface IVisitor{
  void Visit (T1 t1);
  void Visit (T2 t2);
  void Visit (T3 t3);
}[/sourcecode]</p>
<p>Here&rsquo;s an implementation of the visitor, normally you&rsquo;d give default
implementations via and abstract base class. I&rsquo;ll show how that&rsquo;s done later.</p>
<p>[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]class MyVisitor : IVisitor {
  void Visit (T1 t1) {
    // do something here
  }
  void Visit (T2 t2) {
    // do something here
  }
  void Visit (T3 t3) {
    // do something here
  }
}[/sourcecode]</p>
<p>The accept methods are on the domain model entities themselves. What if I have a
composite graph of objects that are not conveniently derived from some abstract
class or interface for my convenience? What if I want to iterate or navigate
the structures in alternate ways. What if I don&rsquo;t want to (or can&rsquo;t) pollute
my domain model with visitation code?</p>
<p>I thought it might be cleaner to factor out the responsibility for the
dispatching into another class - a Dispatcher. I provide the Dispatcher from my
client code and am still able to visit each element in turn. Surprisingly, the
result is slightly cleaner than the standard implementation of the pattern,
sacrificing nothing, but gaining a small increment in applicability.</p>
<p>Let&rsquo;s contrast this canonical implementation with one that uses anemic objects
for the domain model. First we need to define a little composite pattern to
iterate over. This time, I&rsquo;ll give the abstract base class for the entities
and for the visitors and show a composite pattern as well.</p>
<p>[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]abstract class AbstractBase {
  public string Name {get;set;}
}
class Composite : AbstractBase {
  public string NonTerminalIdentifier { get; set; }
  public Composite(string nonTerminalIdentifier) {
    Name = &ldquo;Composite&rdquo;;
    NonTerminalIdentifier = nonTerminalIdentifier;
  }
  public List SubParts = new List();
}
class Primitive1 : AbstractBase {
  public Primitive1() {
    Name = &ldquo;Primitive1&rdquo;;
  }
}
class Primitive2 : AbstractBase {
  public Primitive2() {
    Name = &ldquo;Primitive2&rdquo;;
  }
}[/sourcecode]</p>
<p>A composite class plus a couple of primitives. Next, Lets look at the visitor
interface.</p>
<p>[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]interface IVisitor {
  void Visit(Primitive1 p1);
  void Visit(Primitive2 p2);
  bool StartVisit(Composite c);
  void EndVisit(Composite c);
}[/sourcecode]</p>
<p>According to the discussions at the Portland pattern repository, this could be
called the HierarchicalVisitor pattern, but I suspect most applications of
visitor are over hierarchical object graphs, and they mostly end up like this so
I won&rsquo;t dwell on the name too much. True to form, it provides mechanisms to
visit each type of element allowed in our object graph. Next, the Dispatcher that
controls the navigation over the object graph. This is the departure from the
canonical model. A conventional implementation of visitor places this code in
the composite model itself, which seems unnecessary. Accept overloads are
provided for each type of the domain model.</p>
<p>[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]class Dispatcher {
  public static void Accept(Primitive1 p1, TV visitor)
    where TV : IVisitor {
    visitor.Visit(p1);
  }
  public static void Accept(Primitive2 p2, TV visitor)
    where TV : IVisitor {
    visitor.Visit(p2);
  }
  public static void Accept(Composite c, TV visitor)
    where TV : IVisitor {
    if (visitor.StartVisit(c)) {
      foreach (var subpart in c.SubParts) {
        if (subpart is Primitive1) {
          Accept(subpart as Primitive1, visitor);
        }
        else if (subpart is Primitive2) {
          Accept(subpart as Primitive2, visitor);
        }
        else if (subpart is Composite) {
          Accept(subpart as Composite, visitor);
      }
    }
    visitor.EndVisit(c);
    }
  }
}[/sourcecode]</p>
<p>The dispatcher&rsquo;s first parameter is the object graph element
itself. This provides the context that was implicit with the conventional
implementation. This is a trade-off. On the one hand you cannot access any
private object information inside the dispatch code. On the other hand you can
have multiple different dispatchers for different tasks. Another drawback with
an &lsquo;external&rsquo; dispatcher is the need for old-fashioned dispatcher switch
statements in the Composite acceptor. The Composite stores its sub-parts as
references to the AbstractBase class, so it needs to decide manually what the
Accept method is that must handle the sub-part in question.</p>
<p>The implementation for a visitor is much the same as in a normal implementation.
A default implementation of the visit functions is given that
does nothing. To implement a HierarchicalVisitor, the
default StartVisit must return true to allow iteration of the
subparts of a Composite to proceed.</p>
<p>[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]class BaseVisitor : IVisitor {
  public virtual void Visit(Primitive1 p1) { }
  public virtual void Visit(Primitive2 p2) { }
  public virtual bool StartVisit(Composite c) {
    return true;
  }
  public virtual void EndVisit(Composite c) { }
}[/sourcecode]</p>
<p>Here&rsquo;s a Visitor that simply records the name of who gets visited.</p>
<p>[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]class Visitor : BaseVisitor {
  public override void Visit(Primitive1 p1) {
    Debug.WriteLine(&ldquo;p1&rdquo;);
  }
  public override void Visit(Primitive2 p2) {
    Debug.WriteLine(&ldquo;p2&rdquo;);
  }
  public override bool StartVisit(Composite c) {
    Debug.WriteLine(&quot;-&gt;c&quot;);
    return true;
  }
  public override void EndVisit(Composite c) {
    Debug.WriteLine(&quot;&lt;-c&quot;);
  }
}[/sourcecode]</p>
<p>Given an object graph of type Composite, it is simple to use this little framework.</p>
<p>[sourcecode language=&ldquo;csharp&rdquo; light=&ldquo;true&rdquo; wraplines=&ldquo;true&rdquo;]Dispatcher.Accept(objGraph, new Visitor1());[/sourcecode]</p>
<p>I like this way of working with visitors more than the conventional
implementation - it makes it possible to provide a good visitor implementation on
thrid party frameworks (yes, I&rsquo;m thinking of LINQ expression trees). It is no
more expensive to extend with new visitors, and it has the virtue that you can
navigate an object graph in any fashion you like.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://45.89.107.9/" >
    &copy;  The Wandering Glitch 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
