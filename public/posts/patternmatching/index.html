<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Pattern Matching in C# | The Wandering Glitch</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="I recently used Matthew Podwyszocki&rsquo;s pattern matching classes for a top level exception handler in an App I&rsquo;m writing. Matthew&rsquo;s classes are a really nice fluent interface attaching predicates to functions generating results. I used it as a class factory to select between handlers for exceptions. Here&rsquo;s an example of how I used it:
ExceptionHandler handler = ex.Match() // . . . .With(e =&gt; e.GetType().Equals(typeof(SoapException)), e=&gt; new ReallocateEndpointHandler() as ExceptionHandler) .">
    <meta name="generator" content="Hugo 0.92.2" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Pattern Matching in C#" />
<meta property="og:description" content="I recently used Matthew Podwyszocki&rsquo;s pattern matching classes for a top level exception handler in an App I&rsquo;m writing. Matthew&rsquo;s classes are a really nice fluent interface attaching predicates to functions generating results. I used it as a class factory to select between handlers for exceptions. Here&rsquo;s an example of how I used it:
ExceptionHandler handler = ex.Match() // . . . .With(e =&gt; e.GetType().Equals(typeof(SoapException)), e=&gt; new ReallocateEndpointHandler() as ExceptionHandler) ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://45.89.107.9/posts/patternmatching/" /><meta property="article:section" content="posts" />



<meta itemprop="name" content="Pattern Matching in C#">
<meta itemprop="description" content="I recently used Matthew Podwyszocki&rsquo;s pattern matching classes for a top level exception handler in an App I&rsquo;m writing. Matthew&rsquo;s classes are a really nice fluent interface attaching predicates to functions generating results. I used it as a class factory to select between handlers for exceptions. Here&rsquo;s an example of how I used it:
ExceptionHandler handler = ex.Match() // . . . .With(e =&gt; e.GetType().Equals(typeof(SoapException)), e=&gt; new ReallocateEndpointHandler() as ExceptionHandler) .">

<meta itemprop="wordCount" content="621">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Pattern Matching in C#"/>
<meta name="twitter:description" content="I recently used Matthew Podwyszocki&rsquo;s pattern matching classes for a top level exception handler in an App I&rsquo;m writing. Matthew&rsquo;s classes are a really nice fluent interface attaching predicates to functions generating results. I used it as a class factory to select between handlers for exceptions. Here&rsquo;s an example of how I used it:
ExceptionHandler handler = ex.Match() // . . . .With(e =&gt; e.GetType().Equals(typeof(SoapException)), e=&gt; new ReallocateEndpointHandler() as ExceptionHandler) ."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        The Wandering Glitch
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Pattern Matching in C#</h1>
      
      <p class="tracked">
        By <strong>aabs</strong>
      </p>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>I recently used Matthew Podwyszocki&rsquo;s <a href="http://weblogs.asp.net/podwysocki/archive/2008/09/16/functional-c-pattern-matching.aspx">pattern matching</a> classes for a top level exception handler in an App I&rsquo;m writing. Matthew&rsquo;s classes are a really nice fluent interface attaching predicates to functions generating results. I used it as a class factory to select between handlers for exceptions. Here&rsquo;s an example of how I used it:</p>
<pre><code>ExceptionHandler handler = ex.Match()
    // . . .
    .With(e =&gt; e.GetType().Equals(typeof(SoapException)),
             e=&gt; new ReallocateEndpointHandler() as ExceptionHandler)
    .With(e =&gt; e.Message.Contains(&quot;Could not acquire agent object.&quot;),
             e =&gt; new CleanupSessionHandler() as ExceptionHandler)
    // . . .
    .Else(e=&gt;new ExceptionSwallowingHandler() as ExceptionHandler)
    .Do();
</code></pre>
<p>Clearly a very useful API to provide complex pattern matching against a value. It has two drawbacks that prevented me from using it to do health checking and validation: caching of the pattern matcher and parameterisation of the function with incomming values. You use the above handler on a given value &lsquo;ex&rsquo; in a catch block. I have a whole SOAP API that I&rsquo;m working with that can return similar exceptions, so presently I&rsquo;d need to replicate the above code wherever I wanted to trap exceptions. This is too verbose, so I looked at stripping out some of the components that prevented me from reusing a pattern matcher. Here&rsquo;s an example of what I came up with:</p>
<pre><code>int x = 5;
var fn = SwitchOn&lt;T&gt;.Match()
    .Case(y =&gt; y  y &gt;= 5 &amp;&amp; y  y &gt;10, High)
    .AsFunction();
fn(x);
</code></pre>
<p>The code is much more like a souped up &lsquo;switch&rsquo; statement rather than a souped up assignment statement as it was in Matthew&rsquo;s example. He uses a generic extension method to act as a constructor creating a context object that then constructs the pattern matcher we will really use. The type &lsquo;T&rsquo; for the construction process is thus derived from the type of the object that the Match method is invoked on. The obvious corrolary is that you need to have an object to invoke that extension method on. I didn&rsquo;t want to do it that way because I wanted to create functions that I could invoke later on.</p>
<p>First I converted the extension method to a plain old static method. Here&rsquo;s the SwitchOn&lt;T&gt; class (in Matthew&rsquo;s example it was called PatternMatchExtensions - I renamed it to get a fluent interface that made more sense for how I wanted to use it)</p>
<pre><code>public class SwitchOn&lt;T&gt;{
    public static SwitchOn&lt;T&gt; Match() {
        return new SwitchOn();
    }
    public PatternMatch&lt;T&gt; Case(
        Predicate&lt;T&gt; condition,
        Action&lt;T&gt; result) {
        var match = new PatternMatch&lt;T&gt;();
        return match.Case(condition, result);
    }
}
</code></pre>
<p>As with Matthew&rsquo;s example this object quickly gives way to an object of type PatternMatch&lt;T&gt; that gradually builds up the case list to run against the input data. In my case, though, you don&rsquo;t need to reserve space for the &lsquo;value&rsquo; object, just the type that it will have:</p>
<pre><code>public class PatternMatch&lt;T&gt;{
    private readonly List&lt;Tuple&lt;Predicate&lt;T&gt;, Action&lt;T&gt;&gt;&gt; cases
        = new List&lt;Tuple&lt;Predicate&lt;T&gt;, Action&lt;T&gt;&gt;&gt;();
    private Action&lt;T&gt; elseFunc;
    public PatternMatch&lt;T&gt; Case(Predicate&lt;T&gt; condition, Action&lt;T&gt; result) {
        cases.Add(new Tuple&lt;Predicate&lt;T&gt;, Action&lt;T&gt;&gt;(condition, result));
        return this;
    }
    public PatternMatch&lt;T&gt; Else(Action&lt;T&gt; result) {
        if (elseFunc != null)
            throw new InvalidOperationException(&quot;Cannot have multiple else cases&quot;);
        elseFunc = result;
        return this;
    public Action&lt;T&gt; AsFunction() {
        return t =&gt;{
                    if (elseFunc != null)
                        cases.Add(new Tuple&lt;Predicate&lt;T&gt;, Action&lt;T&gt;&gt;(x =&gt; true,
                            elseFunc));
                    foreach (var item in cases)
                        if (item.First(t)) {
                            item.Second(t);
                            return;
                        }
                    throw new MatchNotFoundException(&quot;Incomplete pattern match&quot;);
                };
    }
}
</code></pre>
<p>The type parameters are different because everywhere he used Func&lt;T, TResult&gt; I am using Action&lt;T&gt; - I don&rsquo;t care about the results. Another difference is that Matthew&rsquo;s &lsquo;Do&rsquo; method is now a higher-order function &lsquo;AsFunction&rsquo; returning a function to apply to a given &lsquo;T&rsquo;. We can store it and pass it around for later use.</p>
<p>Thanks to Matthew for the original inspiration. I hope that this addition fills out more of the PatternMatching picture.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://45.89.107.9/" >
    &copy;  The Wandering Glitch 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
