<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>Domain Analysis (kinda) - The Wandering Glitch</title>
  <meta property="og:title" content="Domain Analysis (kinda) - The Wandering Glitch" />
  <meta name="twitter:title" content="Domain Analysis (kinda) - The Wandering Glitch" />
  <meta name="description" content="I&rsquo;m blogging my progress from mid-way through the project. I have a working prototype, which is a crude implementation of what I want. It has a few limitations which require me to go back and productise it. It may seem a little arbitrary for me to describe a domain split on my second blog post, before even telling you what the requirements are. It&rsquo;s not. It&rsquo;s just that that was what I was thinking about, when I started this blog.">
  <meta property="og:description" content="I&rsquo;m blogging my progress from mid-way through the project. I have a working prototype, which is a crude implementation of what I want. It has a few limitations which require me to go back and productise it. It may seem a little arbitrary for me to describe a domain split on my second blog post, before even telling you what the requirements are. It&rsquo;s not. It&rsquo;s just that that was what I was thinking about, when I started this blog.">
  <meta name="twitter:description" content="I&rsquo;m blogging my progress from mid-way through the project. I have a working prototype, which is a crude implementation of what I want. It has a few limitations which require me to go back and â€¦">
  <meta name="author" content=""/>
  <meta property="og:site_name" content="The Wandering Glitch" />
  <meta property="og:url" content="https://industrialinference.com/1/01/domain-analysis-kinda/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.108.0">

  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/js/fontawesome.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">The Wandering Glitch</a></h1>
    <ul class="site-navi-items">
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">Domain Analysis (kinda)</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>January 1, 0001</time></li>
      </ul>
      
<aside class="toc">
  <nav id="TableOfContents"></nav>
</aside>
      <p>I&rsquo;m blogging my progress from mid-way through the project. I have a working
prototype, which is a crude implementation of what I want. It has a few
limitations which require me to go back and productise it. It may seem a little
arbitrary for me to describe a domain split on my second blog post, before even
telling you what the requirements are. It&rsquo;s not. It&rsquo;s just that that was what I
was thinking about, when I started this blog.</p>
<p>My motivation for this project is long standing. I used Eiffel at university (in
1993!), and since then have always wanted to see declarative predicates attached
to interfaces and classes. Nothing ever came in the languages I use, so I always
end up doing something like this. I wrote a version of this framework for C++
and Java some years ago, and I thought it&rsquo;s time I did the same for C#. I also
want to explore some of the more obscure (and uniquely powerful) language
features of C#, and new features coming with C# v2.0.</p>
<p>I&rsquo;ve split up the broad levels of responsibility into the following:</p>
<ol>
<li>Assertion testing.</li>
<li>Assertion representation</li>
<li>Assertion code generation</li>
<li>Assertion handler assembly management</li>
<li>Assertion failure management</li>
<li>Configuration</li>
<li>Third party code integration</li>
</ol>
<p>Some of these areas I will automatically descope, on the basis that they are
done better elsewhere. For example assertion failure management is done best
using a top level exception management system, or handlers in the code from
which the method invocations came. The Microsoft Enterprise System Exception
Handler Application Block system will allow you to handle exceptions in a
variety of ways, is extensible, and configurable. Lets leave that out. Assertion
testing is probably just an if/then statement. But experience tells me that all
result codes are not equal. HRESULTs needed a specialist test, as do old style C
methods that have zero as a success code, and everything else as failure.</p>
<p>Configuration I have decided to offload onto the new Microsoft Configuration
Application Block. Both came from the ACA.NET framework from Avanade. Kudos to
them, and no bias intended at all from me.</p>
<p>Assertion representation is fairly simple. I have a set of Attributes for each
type of assertion that I wish to make about a program. I have taken these from
Eiffel: Invariant, Require and Ensure. These represent invariant assertions that
must be true in all places and at all times. Ensure and Require are pre- and
post-conditions that apply to whatever they are attached to only. These
attributes store a string representation of the predicate they must enforce. It
is up to this program to turn those string based predicates into lightweight
code that can be applied on every invocation of the method they are attached to.</p>
<p>What I have already for code generation is a simple NVelocity based code
generation template system. It is a dumbed down version of NVelocity, but has
served me well over the years, and has been used in a production environment for
ORM code generation. The system is simple enough to initialise in two lines, and
allows repeated use of the same template with different parameters, so is very
good for doing lots of code generation.</p>
<p>I currently use the CodeDOM framework for the compilation of the generated
source code, and am as yet undecided about what to do with the generated
assemblies. Should I save them to a DLL, and keep them around? Perhaps I could
save myself the code generation step on future runs. I could also use a
Just-In-Time assembly generator and add assertion handlers as they are
encountered.</p>
<p>I am also undecided about whether to generate all of the code for the assembly
inline as proxies, or use some sort of Layer Supertype pattern to outsource the
assertion handling work, and then have a really barebones system emitted
dynamically as MSIL to invoke method on the supertype as necessary.</p>
<p>Assertion handler assembly management is another area where I need to make some
decisions. That will come out of how I solve the code generation issues
described above.</p>
<p>Third party code integration is that part of the design process that makes sure
that the framework is usable with a variety of implementations. For example I
can imagine that this should work with Dynamic and Static proxies. Static are
easier, but are more intrusive potentially. It should also fit into the more
common Aspect Oriented Programming Systems. Again here I am inspired by
Avanade&rsquo;s ACA.NET, which has a very well designed and implemented Aspect
Oriented system, which I&rsquo;m surprised is not in the enterprise Library
Application Blocks.</p>
<p>So, to recap, I plan to write about how I solve the following problems in the
coming weeks/months:</p>
<ol>
<li>Assertion testing.</li>
<li>Assertion representation</li>
<li>Assertion code generation</li>
<li>Assertion handler assembly management</li>
<li>Third party code integration</li>
</ol>
<p>I&rsquo;ll also describe some simple usage scenarios, to put all of this into context,
which I guess will send me back to my university days and my first introduction
to Eiffel. Eiffel is not a .NET compatible language, so you could say I am
wasting my time re-inventing the wheel, when I could just program in Eiffel. My
only excuse is that I first learned to program in C, and I bonded to the syntax.
Anything else seems clunky or sloppy. I know that Eiffel is neither of these
things, but I&rsquo;ve never found a contract for Eiffel either, so I continue to
trade on my C++, Java and C# skills.</p>
<p>There is another, better, reason: I&rsquo;m working as a Solution Architect in
Australia, where I don&rsquo;t get to write the programs I&rsquo;m &lsquo;designing&rsquo;. I&rsquo;m doing
this project in my private time. I need to keep my skills alive until I get a
real project. So I&rsquo;m not in any hurry to get this out, but if at some stage it
gets robust enough to show the world, perhaps you would like to join me in a
GPLd project? There are countless people out there who could do a better job of
the third party framework integrations than me. Are you one of them? Are you
single and have no triplets on the way? (unlike me!) Let me know, and when the
time comes, I&rsquo;ll set up the project.</p>

    </article>

    


    <ul class="pager article-pager">
      <li class="pager-newer">
          <a href="/1/01/does-this-seem-nice-to-you/" data-toggle="tooltip" data-placement="top" title="Does this seem nice to you?">&lt; Newer</a>
      </li>
      <li class="pager-older">
        <a href="/1/01/domain-modeling-and-ontology-engineering/" data-toggle="tooltip" data-placement="top" title="Domain Modeling and Ontology Engineering">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright">Andrew Matthews</div>
  <ul class="site-footer-items">
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>


</body>
</html>
