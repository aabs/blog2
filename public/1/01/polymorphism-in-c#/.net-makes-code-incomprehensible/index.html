<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
  Polymorphism in C#/.NET Makes Code Incomprehensible · The Wandering Glitch
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="description" content="I&rsquo;ve recently been working on a series of blog posts that require me to reverse engineer the contents of the LINQ assembly System.Query. My experience has largely been very positive, but I have one problem that has slowed my progress – navigating beyond polymorphic method calls. This isn&rsquo;t a problem with LINQ (it uses polymorphism in a number of key places) it&rsquo;s a problem with code reading generally.
I find that while abstraction frameworks are essential to allow clean factoring and decoupling of object models, they make interpretation of runtime behaviour very hard – the more fully encapsulated a framework is, the harder it is to read it&rsquo;s code and deduce how it works.">
<meta name="keywords" content="">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Polymorphism in C#/.NET Makes Code Incomprehensible"/>
<meta name="twitter:description" content="I&rsquo;ve recently been working on a series of blog posts that require me to reverse engineer the contents of the LINQ assembly System.Query. My experience has largely been very positive, but I have one problem that has slowed my progress – navigating beyond polymorphic method calls. This isn&rsquo;t a problem with LINQ (it uses polymorphism in a number of key places) it&rsquo;s a problem with code reading generally.
I find that while abstraction frameworks are essential to allow clean factoring and decoupling of object models, they make interpretation of runtime behaviour very hard – the more fully encapsulated a framework is, the harder it is to read it&rsquo;s code and deduce how it works."/>

<meta property="og:title" content="Polymorphism in C#/.NET Makes Code Incomprehensible" />
<meta property="og:description" content="I&rsquo;ve recently been working on a series of blog posts that require me to reverse engineer the contents of the LINQ assembly System.Query. My experience has largely been very positive, but I have one problem that has slowed my progress – navigating beyond polymorphic method calls. This isn&rsquo;t a problem with LINQ (it uses polymorphism in a number of key places) it&rsquo;s a problem with code reading generally.
I find that while abstraction frameworks are essential to allow clean factoring and decoupling of object models, they make interpretation of runtime behaviour very hard – the more fully encapsulated a framework is, the harder it is to read it&rsquo;s code and deduce how it works." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://industrialinference.com/1/01/polymorphism-in-c#/.net-makes-code-incomprehensible/" /><meta property="article:section" content="posts" />






<link rel="canonical" href="https://industrialinference.com/1/01/polymorphism-in-c#/.net-makes-code-incomprehensible/">


<link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.7f9d180e3b3bebba9ba80d55eed1255c35e00764872854736d6ad7db38884ffc.css" integrity="sha256-f50YDjs767qbqA1V7tElXDXgB2SHKFRzbWrX2ziIT/w=" crossorigin="anonymous" media="screen" />








 




<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">




<meta name="generator" content="Hugo 0.108.0">





  </head>




<body class="preload-transitions colorscheme-light">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      The Wandering Glitch
    </a>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://industrialinference.com/1/01/polymorphism-in-c#/.net-makes-code-incomprehensible/">
              Polymorphism in C#/.NET Makes Code Incomprehensible
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="0001-01-01T00:00:00Z">
                January 1, 0001
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              2-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div>
        
        <p>I&rsquo;ve recently been working on a series of blog posts that require me to reverse engineer the contents of the LINQ assembly System.Query. My experience has largely been very positive, but I have one problem that has slowed my progress – navigating beyond polymorphic method calls. This isn&rsquo;t a problem with LINQ (it uses polymorphism in a number of key places) it&rsquo;s a problem with code reading generally.</p>
<p>I find that while abstraction frameworks are essential to allow clean factoring and decoupling of object models, they make interpretation of runtime behaviour <em><strong>very hard</strong></em> – the more fully encapsulated a framework is, the harder it is to read it&rsquo;s code and deduce how it works.</p>
<p>I don&rsquo;t have a problem with polymorphism as a rule, well I do, but it&rsquo;s a price I am more than willing to pay. But I really have struggled to get through the LINQ code base – it is complex enough, without me being hindered at every step by the fact that I have to guess what is going on at runtime for a specific combination of parameters. The struggle for me was keeping it all in my head – the structure of the LINQ expression tree (specifically the Type of each node in the tree), the call stack, the type parameters passed to generic methods, and the progress in iterating collections of those types. It&rsquo;s hard, and it&rsquo;s not using everyday idioms so you can&rsquo;t guess with very much confidence what it ought to be doing. I wonder whether there might be some tool support that I can exploit to ease the code reading process.</p>
<p>If you know of a tool (or some way to augment the debugger) that will allow me to profile the LINQ expression creation and compilation at runtime, please let me know. I&rsquo;ve tried combinations of <a href="http://www.aisto.com/roeder/dotnet/">Reflector</a>, <a href="http://www.acorns.com.au/hawkeye/">Hawkeye</a> and <a href="http://www.jetbrains.com/profiler/">dotTrace</a>. None of them were able to penetrate the fog individually, and were impossible to use in combination. Perhaps you know of a way to tackle these issues?</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2022
    
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.27afce394fb6284f521b3fbc9f6a8326342333c3092267f3944d770489876fed.js" integrity="sha256-J6/OOU&#43;2KE9SGz&#43;8n2qDJjQjM8MJImfzlE13BImHb&#43;0="></script>
  

  

  

  

  

  

  

  

  

  
</body>

</html>
