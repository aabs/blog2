<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>A simple semantic web application in C# - The Wandering Glitch</title>
  <meta property="og:title" content="A simple semantic web application in C# - The Wandering Glitch" />
  <meta name="twitter:title" content="A simple semantic web application in C# - The Wandering Glitch" />
  <meta name="description" content="[digg=http://www.digg.com/programming/A_simple_semantic_web_application_in_C]The latest update of the SemWeb library from Josh Tauberer includes a C# implementation of the Euler reasoner. This reasoner is able to go beyond simplistic RDFS reasoning – being able to navigate the class and property relationships - to make use of rules. The ontology I&rsquo;ve been using to get used to coding in the framework models a simple state machine. The ontology couldn&rsquo;t be simpler. Here&rsquo;s an N3 file that declares the classes and their relationships.">
  <meta property="og:description" content="[digg=http://www.digg.com/programming/A_simple_semantic_web_application_in_C]The latest update of the SemWeb library from Josh Tauberer includes a C# implementation of the Euler reasoner. This reasoner is able to go beyond simplistic RDFS reasoning – being able to navigate the class and property relationships - to make use of rules. The ontology I&rsquo;ve been using to get used to coding in the framework models a simple state machine. The ontology couldn&rsquo;t be simpler. Here&rsquo;s an N3 file that declares the classes and their relationships.">
  <meta name="twitter:description" content="[digg=http://www.digg.com/programming/A_simple_semantic_web_application_in_C]The latest update of the SemWeb library from Josh Tauberer includes a C# implementation of the Euler reasoner. This …">
  <meta name="author" content=""/>
  <meta property="og:site_name" content="The Wandering Glitch" />
  <meta property="og:url" content="https://industrialinference.com/1/01/a-simple-semantic-web-application-in-c/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.108.0">

  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/js/fontawesome.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">The Wandering Glitch</a></h1>
    <ul class="site-navi-items">
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">A simple semantic web application in C#</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>January 1, 0001</time></li>
      </ul>
      
<aside class="toc">
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#what-to-notice">What to notice</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>
      <p>[digg=http://www.digg.com/programming/A_simple_semantic_web_application_in_C]The
latest update of the <a href="http://razor.occams.info/code/semweb/">SemWeb</a> library
from Josh Tauberer includes a C# implementation of the
<a href="http://www.agfa.com/w3c/euler/">Euler</a> reasoner. This reasoner is able to go
beyond simplistic RDFS reasoning – being able to navigate the class and property
relationships - to make use of rules. The ontology I&rsquo;ve been using to get used
to coding in the framework models a simple state machine. The ontology couldn&rsquo;t
be simpler. Here&rsquo;s an <a href="http://www.w3.org/2000/10/swap/Primer.html">N3</a> file that
declares the classes and their relationships.</p>
<pre tabindex="0"><code>@prefix daml:  . @prefix rdfs:  . @prefix owl:   . @prefix : .
#Classes :State a owl:Class;
daml:comment &#34;states the system can be in&#34;;
daml:disjointUnionOf ( :S1 :S2 :S3 ).
:InputToken a owl:Class;
daml:comment &#34;inputs to the system&#34;;
daml:disjointUnionOf ( :INil :I1 :I2 ).
:Machine a owl:Class. :System a owl:Class.
#properties :isInState rdfs:domain :Machine;
rdfs:range  :State;
owl:cardinality &#34;1&#34;.
:hasInput rdfs:domain :System;
rdfs:range  :InputToken;
owl:cardinality &#34;1&#34;.
#Instances :Machine1 a :Machine;
:isInState :S1.
:This a :System;
:hasInput   :INil.
</code></pre><p>As with any deterministic finite state <a href="http://aabs.wordpress.com/2007/01/16/342/">machine</a>, there are two key classes at work here. :State and :InputToken. State is a disjoint union of :S1, :S2 and :S3. That means that :S1 is not an :S2 or an :S3. If you don&rsquo;t specify such a disjunction, the reasoners cannot assume it – if there is no rule that says they are disjoint, the reasoner won&rsquo;t be able to assume they&rsquo;re different - just because Machine1 is in state S1, doesn&rsquo;t mean it isn&rsquo;t potentially in state S2 as well. You have to tell it that an S1 is not an S2. Pedantry is all-important in ontology design, and while I have gained a fair measure of it over the years as a defensive programmer I was shocked at the level of semantic support I get from the programming languages I use. OWL provides you with such a rich palette to work with, but less conventional support. It is kind of liberating to be designing class libraries in <a href="http://www.w3.org/2004/OWL/">OWL</a> vs. OO languages. Kind of like when you go from DOS to Bash.</p>
<p>Anyway, the rules for this little ontology define a transition table for the state machine:</p>
<pre tabindex="0"><code>@prefix log:  . @prefix rdfs:  . @prefix owl:   . @prefix : .
#  ~&gt; {
    :Machine1 :isInState  :S1. :This :hasInput :I1. } =&gt; {
    :Machine1 :isInState  :S1. :This :hasInput :INil. }.
#  ~&gt; {
    :Machine1 :isInState  :S1. :This :hasInput :I2. } =&gt; {
    :Machine1 :isInState  :S2. :This :hasInput :INil. }.
#  ~&gt; {
    :Machine1 :isInState  :S1. :This :hasInput :I3. } =&gt; {
    :Machine1 :isInState  :S3. :This :hasInput :INil.}.
</code></pre><p>I got into problems initially, since I thought about the problem from an
imperative programming perspective. I designed it like I was assigning values to
variables. That&rsquo;s the wrong approach – treat this as adding facts to what is
already known. So, rather than saying <em>if X, then do Y,</em> think of it as <em>if I
know X, then I also know that Y.</em> The program to work with it looks like this:</p>
<pre tabindex="0"><code>internal class Program {
    private static readonly string ontologyLocation = @&#34;C:\dev\prototypes\semantic-web\ontologies\20074\states\&#34;;
    private static string baseUri = @&#34;file:///C:/dev/prototypes/semantic-web/ontologies/2007/04/states/states.rdf#&#34;;
    private static MemoryStore store = new MemoryStore();
    private static Entity Machine1 = new Entity(baseUri + &#34;Machine1&#34;);
    private static Entity Input1 = new Entity(baseUri + &#34;I1&#34;);
    private static Entity Input2 = new Entity(baseUri + &#34;I2&#34;);
    private static Entity theSystem = new Entity(baseUri + &#34;This&#34;);
    private static string hasInput = baseUri + &#34;hasInput&#34;;
    private static string isInState = baseUri + &#34;isInState&#34;;
    private static void Main(string[] args) {
    InitialiseStore();
    DisplayCurrentStates();
    SetNewInput(Input2);
    DisplayCurrentStates();
}
private static void DisplayCurrentStates() {
    SelectResult ra = store.Select(new Statement(Machine1, new Entity(isInState), null));
    Debug.Write(&#34;Current states: &#34;);
    foreach (Statement resource in ra.ToArray()) {
        Debug.Write(resource.Object.Uri);
    }
    Debug.WriteLine(&#34;&#34;);
}
private static void InitialiseStore() {
    string statesLocation = Path.Combine(ontologyLocation, &#34;states.n3&#34;);
    string rulesLocation = Path.Combine(ontologyLocation, &#34;rules.n3&#34;);
    Euler engine = new Euler(new N3Reader(File.OpenText(rulesLocation)));
    store.Import(new N3Reader(File.OpenText(statesLocation)));
    store.AddReasoner(engine);
}
private static void SetNewInput(Entity newInput) {
    Resource[] currentInput = store.SelectObjects(theSystem, hasInput);
    Statement input = new Statement(theSystem, hasInput, Input1);
    store.Remove(new Statement(theSystem, hasInput, currentInput[0]));
    store.Add(new Statement(theSystem, hasInput, newInput));
    Resource[] subsequentState = store.SelectObjects(Machine1, isInState);
    Statement newState = new Statement(Machine1, isInState, subsequentState[0]);
    store.Replace(new Statement(Machine1, isInState, null), newState);
} }
</code></pre><p>The task was simple – I wanted to set the state machine up in state :S1 with
input :INil, then put input :I1 in, and see the state change from :S1 to :S2. In
doing this I am trying to do something that is a little at odds with the
expressed intention of ontologies. They are more static declarations of a body
of knowledge as much as a specification for a dynamically changing body of
facts. What that means is that they are <em>additive</em> – the frameworks and
reasoners allow you to add to a body of knowledge. That makes reuse and trust
possible on the semantic
web[<a href="http://www.w3.org/TR/owl-semantics/rdfs.html">1</a>,
<a href="http://www.w3.org/DesignIssues/N3Logic">2</a>]. If I can take your ontology and
change it to mean something other than what you intended then no guarantees can
be made about the result. The ontology should stand alone – if you want to base
some data on it, that&rsquo;s up to you, and you will have to manage it. In practical
terms, that means you have to manually change the entries for the input and the
states as they change. What the ontology adds is a framework for representing
the data, and a set of rules for working out what the next state should be.
That&rsquo;s still powerful, but I wonder how well it would scale.</p>
<h3 id="what-to-notice">What to notice</h3>
<p>There are a few things in here that you should pay very close attention to if
you want to write a semantic web application of your own using SemWeb. Firstly,
the default namespace definition in the ontology and rules definition files.
Generally, the examples of N3 files on the W3C site use the following format to
specify the default namespace of a file:</p>
<pre tabindex="0"><code>@prefix : &lt;#&gt;
</code></pre><p>Unfortunately that leaves a little too much room for manoeuvring within SemWeb,
and the actual URIs that it will use are a little unpredictable. Generally they
are based upon the location that SemWeb got the files from. Instead, choose a
URL like so:</p>
<p>[@prefix : &lt;http://aabs.purl.org/ontologies/2007/04/states/states.rdf#&gt;.
]{style=&ldquo;font-family:Courier New;font-size:10pt;&rdquo;}</p>
<p>This was not the location of the file - it was just a URL I was using prior to
using N3 format. The point is that you just need to give an unambiguous URL so
that the semweb and its reasoner can distinguish resources properly, when you
ask it questions. I used the same URL in the rules.n3 file, since most of what I
was referring to was defined in the namespace above. I could just as easily have
defined a new prefix for states.n3 and prepended all the elements in the rules
with that prefix. The point is to have a non-default URL so that semweb is in no
doubt about what the URL of the resources are that you are referring to.</p>
<p>Next, remember that you will have to dip into the instances in the store to make
manual changes to their state – this is no different from any relational
database application. Although, I was disconcerted at first, because I had hoped
that the reasoner would make any changes I needed for me. Alas that is not in
the spirit of the semantic web apparently, so be prepared to manage the system
closely.</p>
<p>I think that the use of OWL ontologies would be very easy for question answering
applications, but there may be a little more work required to place a reasoner
at the core of your system. Of course, I could be wrong about that, and it could
be my incorrigable procedural mindset that is to blame – I will keep you posted.
I&rsquo;ll be posting more on this over the next few weeks, so if there are things you
want me to write about, or answers to questions you have, pllease drop me a line
or comment here, and I&rsquo;ll try to come up with answers.</p>

    </article>

    


    <ul class="pager article-pager">
      <li class="pager-newer">
          <a href="/1/01/a-simple-interface-to-timercallback/" data-toggle="tooltip" data-placement="top" title="A Simple Interface to TimerCallback">&lt; Newer</a>
      </li>
      <li class="pager-older">
        <a href="/1/01/a-speculative-notation/" data-toggle="tooltip" data-placement="top" title="A Speculative Notation">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright">Andrew Matthews</div>
  <ul class="site-footer-items">
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>


</body>
</html>
